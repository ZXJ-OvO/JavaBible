# Java

## SE基础

### 基础概念

#### Java 语言有哪些特点?

1. 简单易学；
2. 面向对象；
3. 可移植性；
4. 支持多线程；
5. 可靠性（具备异常处理和自动内存管理机制）；
6. 安全性（Java 语言本身的设计就提供了多重安全防护机制如访问权限修饰符、限制程序直接访问操作系统资源）；
7. 高效性（Just In Time 编译器等技术的优化）；
8. 支持网络编程；
9. 编译与解释并存；
10. 强大的生态



#### JVM vs JDK vs JRE

![jdk-include-jre](https://raw.githubusercontent.com/ZXJ-OvO/picgo-img/master/202307081015692.png)



####  什么是字节码?采用字节码的好处是什么?

1. 在 Java 中，JVM 可以理解的代码就叫做字节码，即扩展名为 `.class` 的文件，它不面向任何特定的处理器，只面向虚拟机。
2. Java 语言通过字节码的方式，在一定程度上解决了传统解释型语言执行效率低的问题，同时又保留了解释型语言可移植的特点。因此，Java 程序运行时相对来说还是高效的，而且，由于字节码并不针对一种特定的机器，因此实现了一次编译随处运行。



#### 为什么说Java 是编译与解释共存的语言

`.class->机器码` 这一步 **JVM 类加载器**首先加载字节码文件，然后通过**解释器**逐行解释执行，这种方式的执行速度会相对比较慢。而且，有些方法和代码块是经常需要被调用的（即热点代码），所以后面引进了 JIT（just-in-time compilation） 编译器，而 JIT 属于运行时编译。当 JIT 编译器完成第一次编译后，其会将字节码对应的机器码保存下来，下次可以直接使用。而我们知道，机器码的运行效率肯定是高于 Java 解释器的。这也解释了我们为什么经常会说 **Java 是编译与解释共存的语言** 。

HotSpot 采用了惰性评估(Lazy Evaluation)的做法，根据二八定律，消耗大部分系统资源的只有那一小部分的代码（热点代码），而这也就是 JIT 所需要编译的部分。JVM 会根据代码每次被执行的情况收集信息并相应地做出一些优化，因此执行的次数越多，它的速度就越快。

JDK 9 引入了一种新的编译模式 AOT(Ahead of Time Compilation)，它是直接将字节码编译成机器码，这样就避免了 JIT 预热等各方面的开销。JDK 支持分层编译和 AOT 协作使用。

![image-20230708103222895](https://raw.githubusercontent.com/ZXJ-OvO/picgo-img/master/202307081032928.png)



#### AOT 可以提前编译节省启动时间为什么不全部使用 AOT 

这和 Java 语言的动态特性有联关系。例如，CGLIB 动态代理使用的是 ASM 技术，而这种技术大致原理是运行时直接在内存中生成并加载修改后的字节码文件也就是 `.class` 文件，如果全部使用 AOT 提前编译，也就不能使用 ASM 技术了。为了支持类似的动态特性，所以选择使用 JIT 即时编译器。



#### Oracle JDK vs OpenJDK

| Oracle JDK           | Open JDK      |
| -------------------- | ------------- |
| 部分内容闭源         | 完全开源      |
| 有限的免费版本       | 完全免费      |
| 功能更强             | 基础功能      |
| 约3年发布一个LTS版本 | 不提供LTS版本 |



### 基本语法

#### 注释有哪几种形式？

1. **单行注释**：通常用于解释方法内某单行代码的作用。
2. **多行注释**：通常用于解释一段代码的作用。
3. **文档注释**：通常用于生成 Java 开发文档。



####  标识符和关键字的区别是什么？

标识符就是一个名字，关键字是被赋予特殊含义的标识符。

|                      |          |            | 关键字   |              |            |           |        |
| :------------------- | -------- | ---------- | -------- | ------------ | ---------- | --------- | ------ |
| 分类                 | 关键字   |            |          |              |            |           |        |
| 访问控制             | private  | protected  | public   |              |            |           |        |
| 类，方法和变量修饰符 | abstract | class      | extends  | final        | implements | interface | native |
|                      | new      | static     | strictfp | synchronized | transient  | volatile  | enum   |
| 程序控制             | break    | continue   | return   | do           | while      | if        | else   |
|                      | for      | instanceof | switch   | case         | default    | assert    |        |
| 错误处理             | try      | catch      | throw    | throws       | finally    |           |        |
| 包相关               | import   | package    |          |              |            |           |        |
| 基本类型             | boolean  | byte       | char     | double       | float      | int       | long   |
|                      | short    |            |          |              |            |           |        |
| 变量引用             | super    | this       | void     |              |            |           |        |
| 保留字               | goto     | const      |          |              |            |           |        |

> ⚠️ 注意：虽然 `true`, `false`, 和 `null` 看起来像关键字但实际上他们是字面值，同时也不可以作为标识符来使用。



####  自增自减运算符

“符号在前就先加/减，符号在后就后加/减”。



#### 移位运算符

- `<<` :左移运算符，向左移若干位，高位丢弃，低位补零。`x << 1`,相当于 x 乘以 2(不溢出的情况下)。
- `>>` :带符号右移，向右移若干位，高位补符号位，低位丢弃。正数高位补 0,负数高位补 1。`x >> 1`,相当于 x 除以 2。
- `>>>` :无符号右移，忽略符号位，空位都以 0 补齐。

>由于 `double`，`float` 在二进制中的表现比较特殊，因此不能来进行移位操作。
>
>移位操作符实际上支持的类型只有`int`和`long`，编译器在对`short`、`byte`、`char`类型进行移位前，都会将其转换为`int`类型再操作。
>
><hr/>
>
>当 int 类型左移/右移位数大于等于 32 位操作时，会先求余（%）后再进行左移/右移操作。也就是说左移/右移 32 位相当于不进行移位操作（32%32=0），左移/右移 42 位相当于左移/右移 10 位（42%32=10）。当 long 类型进行左移/右移操作时，由于 long 对应的二进制是 64 位，因此求余操作的基数也变成了 64。
>
>也就是说：`x<<42`等同于`x<<10`，`x>>42`等同于`x>>10`，`x >>>42`等同于`x >>> 10`。

```java
// 右移运算符代码示例：

int i = -1;
System.out.println("初始数据：" + i);
System.out.println("初始数据对应的二进制字符串：" + Integer.toBinaryString(i));
i <<= 10;
System.out.println("左移 10 位后的数据 " + i);
System.out.println("左移 10 位后的数据对应的二进制字符 " + Integer.toBinaryString(i));
i <<= 42;
System.out.println("左移 10 位后的数据 " + i);
System.out.println("左移 10 位后的数据对应的二进制字符 " + Integer.toBinaryString(i));
```

```
// 输出

初始数据：-1
初始数据对应的二进制字符串：11111111111111111111111111111111
左移 10 位后的数据 -1024
左移 10 位后的数据对应的二进制字符 11111111111111111111110000000000
左移 10 位后的数据 -1024
左移 10 位后的数据对应的二进制字符 11111111111111111111110000000000
```



####  continue、break 和 return 的区别是什么？

1. `continue`：指跳出当前的这一次循环，继续下一次循环。
2. `break`：指跳出整个循环体，继续执行循环下面的语句。
3. `return` 用于跳出所在方法，结束该方法的运行。return 一般有两种用法：
   - `return;`：直接使用 return 结束方法执行，用于没有返回值函数的方法。
   - `return value;`：return 一个特定值，用于有返回值函数的方法。



### 基本数据类型

#### Java 中的几种基本数据类型了解么？

| 基本类型  | 位数 | 字节 | 默认值  | 取值范围                                   | 包装类    |
| :-------- | :--- | :--- | :------ | ------------------------------------------ | --------- |
| `byte`    | 8    | 1    | 0       | -128 ~ 127                                 | Byte      |
| `short`   | 16   | 2    | 0       | -32768 ~ 32767                             | Short     |
| `int`     | 32   | 4    | 0       | -2147483648 ~ 2147483647                   | Integer   |
| `long`    | 64   | 8    | 0L      | -9223372036854775808 ~ 9223372036854775807 | Long      |
| `char`    | 16   | 2    | 'u0000' | 0 ~ 65535                                  | Character |
| `float`   | 32   | 4    | 0f      | 1.4E-45 ~ 3.4028235E38                     | Float     |
| `double`  | 64   | 8    | 0d      | 4.9E-324 ~ 1.7976931348623157E308          | Double    |
| `boolean` | 1    |      | false   | true、false                                | Boolean   |

> - 在Java中，局部变量（如在方法内部定义的变量）没有默认值，必须显式地初始化才能使用。这是因为局部变量的值是不确定的，直到你为其赋予一个具体的值。
> - 但是类的成员变量（即类的字段）会根据其类型有默认值。
> - 所有引用类型的默认值都是null（包装类属于引用类型）。



#### 基本数据类型和包装类型的区别？

1. **用途**：除了定义一些常量和局部变量之外，在其他地方很少使用基本类型。并且包装类型可用于泛型，基本类型不可以。
2. **存储方式**：基本数据类型的局部变量存放在 Java 虚拟机栈中的局部变量表中，基本数据类型的成员变量（未被 `static` 修饰 【static修饰】的静态变量位于方法区中）存放在 Java 虚拟机的堆中。包装类型属于对象类型，我们知道几乎所有对象实例都存在于堆中。
3. **占用空间**：相比于包装类型（对象类型）， 基本数据类型占用的空间往往非常小。
4. **默认值**：成员变量包装类型不赋值就是 `null` ，而基本类型有默认值且不是 `null`。
5. **比较方式**：对于基本数据类型来说，`==` 比较的是值。对于包装数据类型来说，`==` 比较的是对象的内存地址。所有整型包装类对象之间值的比较，全部使用 `equals()` 方法。

**为什么说是几乎所有对象实例都存在于堆中呢？** 这是因为 HotSpot 虚拟机引入了 JIT 优化之后，会对对象进行逃逸分析，如果发现某一个对象并没有逃逸到方法外部，那么就可能通过标量替换来实现栈上分配，而避免堆上分配内存。

> ⚠️ 注意：**基本数据类型存放在栈中是一个常见的误区！** 基本数据类型的成员变量如果没有被 `static` 修饰的话（不建议这么使用，应该要使用基本数据类型对应的包装类型），就存放在堆中。



#### 包装类型的缓存机制了解么？

Java 基本数据类型的包装类型的大部分都用到了缓存机制来提升性能。

- `Byte`,`Short`,`Integer`,`Long` 这 4 种包装类默认创建了数值 **[-128，127]** 的相应类型的缓存数据。
- `Character` 创建了数值在 **[0,127]** 范围的缓存数据。
- `Boolean` 直接返回 `True` or `False`。
- 如果超出对应范围仍然会去创建新的对象，缓存的范围区间的大小只是在性能和资源之间的权衡。
- 两种浮点数类型的包装类 `Float`,`Double` 并没有实现缓存机制。

```java
int a = 100;
int b = 200;

Integer c = a; // 100
Integer d = a; // 100
Integer e = b; // 200
Integer f = b; // 200

long l = 100l;
Long ll = l; // 100

System.out.println(c == d);       //true  Integer值100在Integer的缓存范围中，所以指向同一个对象，即地址相同
System.out.println(e == f);       //false Integer的缓存范围是-128~127，200超出了缓存范围中，所以指向不同的对象，即地址不同
System.out.println(a == l);       //true  字符串常量池中byte short int long类型的范围是-128~127，所以指向同一个对象，即地址相同
System.out.println(c == l);       //true  包装类在与基本数据类型做==比较时，包装类型会自动拆箱为基本数据类型，所以比较的是基本数据类型，即地址相同
System.out.println(e.equals(f));  //true  包装类的equals方法重写过，当比较双方的类型不同时，返回false；当比较双方的类型相同时，比较的是实际数据值
System.out.println(c.equals(l));  //false 类型不同，返回false
System.out.println(c.equals(ll)); //false 类型不同，返回false

Float i11 = 333f;
Float i22 = 333f;
System.out.println(i11 == i22);// 输出 false

Double i3 = 1.2;
Double i4 = 1.2;
System.out.println(i3 == i4);// 输出 false

Integer i1 = 40;
Integer i2 = new Integer(40);
System.out.println(i1 == i2);        // false
// Integer i1=40 会发生装箱，等价于Integer i1=Integer.valueOf(40) 因此，i1 直接使用的是缓存中的对象。而Integer i2 = new Integer(40) 会直接创建新的对象。
```

> 《阿里巴巴Java开发规约》【强制】**所有整型包装类对象之间值的比较，全部使用 equals 方法比较**



#### 自动装箱与拆箱了解吗？原理是什么？

- **装箱**：将基本类型用它们对应的引用类型包装起来；
- **拆箱**：将包装类型转换为基本数据类型；

装箱其实就是调用了 包装类的`valueOf()`方法，拆箱其实就是调用了 `xxxValue()`方法。

因此，

- `Integer i = 10` 等价于 `Integer i = Integer.valueOf(10)`

- `int n = i` 等价于 `int n = i.intValue()`;

> ⚠️**如果频繁拆装箱的话，也会严重影响系统的性能。我们应该尽量避免不必要的拆装箱操作。**



#### 为什么浮点数运算的时候会有精度丢失的风险？

计算机底层是二进制的，而且计算机在表示一个数字时，宽度是有限的，无限循环的小数存储在计算机时，只能被截断，所以就会导致小数精度发生损失的情况。



#### 如何解决浮点数运算的精度丢失问题？

`BigDecimal` 可以实现对浮点数的运算，不会造成精度丢失。通常情况下，大部分需要浮点数精确运算结果的业务场景（比如涉及到钱的场景）都是通过 `BigDecimal` 来做的。



#### 超过 long 整型的数据应该如何表示？

`BigInteger` 内部使用 `int[]` 数组来存储任意大小的整形数据。

相对于常规整数类型的运算来说，`BigInteger` 运算的效率会相对较低。



### 变量

#### 成员变量与局部变量的区别？

|          | 成员变量                                                     | 局部变量                                                     |
| -------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 定义位置 | 属于类（类中方法外）                                         | 代码块、方法内的变量、方法的参数                             |
| 修饰符   | public、private、static、final                               | final                                                        |
| 存储方式 | 静态成员变量（类变量）：方法区<br />非静态成员变量（实例变量）：堆内存 | 栈内存                                                       |
| 生存时间 | 实例变量随着对象的创建而诞生，随着对象的消亡而消亡<br />类变量在程序执行期间一直存在，被所有对象实例共享 | 局部变量的生存时间仅限于它们所在的作用域，当作用域结束时销毁 |
| 默认值   | 从变量是否有默认值来看，成员变量如果没有被赋初始值，则会自动以类型的默认值而赋值（一种情况例外:被 `final` 修饰的成员变量也必须显式地赋值） | 而局部变量则不会自动赋值                                     |



####  静态变量有什么作用？

- 静态变量也就是被 `static` 关键字修饰的变量。它可以被类的所有实例共享，无论一个类创建了多少个对象，它们都共享同一份静态变量。也就是说，静态变量只会被分配一次内存，即使创建多个对象，这样可以节省内存。
- 静态变量是通过类名来访问的（如果被 `private`关键字修饰就无法这样访问了，可以提供暴露的方法进行访问）。
- 通常情况下，静态变量会被 `final` 关键字修饰成为常量。



####  字符型常量和字符串常量的区别?

- **形式** : 字符常量是单引号引起的一个字符，字符串常量是双引号引起的 0 个或若干个字符。
- **含义** : 字符常量相当于一个整型值( ASCII 值),可以参加表达式运算; 字符串常量代表一个地址值(该字符串在内存中存放位置)。
- **占内存大小**：字符常量只占 2 个字节; 字符串常量占若干个字节。



### 方法

#### 什么是方法的返回值?方法有哪几种类型？

**方法的返回值** 是指我们获取到的某个方法体中的代码执行后产生的结果！（前提是方法返回某个值）

按照方法的返回值和参数类型将方法分为下面这几种：

1. 无参数无返回值的方法
2. 有参数无返回值的方法
3. 无参数有返回值的方法
4. 有参数有返回值的方法



#### 静态方法为什么不能调用非静态成员?

1. 静态方法是属于类的，在类加载的时候就会分配内存，可以通过类名直接访问。而非静态成员属于实例对象，只有在对象实例化之后才存在，需要通过类的实例对象去访问。
2. 在类的非静态成员不存在的时候静态方法就已经存在了，此时调用在内存中还不存在的非静态成员，属于非法操作。



#### 静态方法和实例方法有何不同？

1. 调用方式
   - 在外部调用静态方法时，可以使用 `类名.方法名` 的方式，也可以使用 `对象.方法名` 的方式，而实例方法只有后面这种方式。也就是说，**调用静态方法可以无需创建对象** 。
   - 不过，需要注意的是一般不建议使用 `对象.方法名` 的方式来调用静态方法。这种方式非常容易造成混淆，静态方法不属于类的某个对象而是属于这个类。
   - 因此，一般建议使用 `类名.方法名` 的方式来调用静态方法。

2. 访问类成员是否存在限制
   - 静态方法在访问本类的成员时，只允许访问静态成员（即静态成员变量和静态方法）。
   - 不允许访问实例成员（即实例成员变量和实例方法），而实例方法不存在这个限制。



####  重载和重写有什么区别？

| 区别点     | 重载方法 | 重写方法                                                     |
| :--------- | :------- | :----------------------------------------------------------- |
| 发生范围   | 同一个类 | 子类                                                         |
| 参数列表   | 必须修改 | 一定不能修改                                                 |
| 返回类型   | 可修改   | 子类方法返回值类型应比父类方法返回值类型更小或相等           |
| 异常       | 可修改   | 子类方法声明抛出的异常类应比父类方法声明抛出的异常类更小或相等 |
| 访问修饰符 | 可修改   | 子类的访问修饰符范围大于等于父类                             |
| 发生阶段   | 编译期   | 运行期                                                       |

> 关于 **重写的返回值类型** 这里需要额外多说明一下，上面的表述不太清晰准确：如果方法的返回类型是 void 和基本数据类型，则返回值重写时不可修改。但是如果方法的返回值是引用类型，重写时是可以返回该引用类型的子类的。



#### 什么是可变长参数？

- 从 Java5 开始，Java 支持定义可变长参数，所谓可变长参数就是允许在调用方法时传入不定长度（0个或者多个）的参数。
- 可变参数只能作为函数的最后一个参数，但其前面可以有也可以没有任何其他参数。
- Java 的可变参数编译后实际会被转换成一个数组。

> 遇到方法重载的情况，优先匹配固定参数的方法，因为固定参数的方法匹配度更高。



### 面向对象基础

#### 面向对象和面向过程的区别

- 面向过程把解决问题的过程拆成一个个方法，通过一个个方法的执行解决问题。
- 面向对象会先抽象出对象，然后用对象执行方法的方式解决问题。

另外，面向对象开发的程序一般更易维护、易复用、易扩展。



#### 创建一个对象用什么运算符-对象实体与对象引用有何不同

new 运算符，new 创建对象实例（对象实例在 内存中），对象引用指向对象实例（对象引用存放在栈内存中）。

- 一个对象引用可以指向 0 个或 1 个对象（一根绳子可以不系气球，也可以系一个气球）。
- 一个对象可以有 n 个引用指向它（可以用 n 条绳子系住一个气球）。



#### 对象的相等和引用相等的区别

- 对象的相等一般比较的是内存中存放的内容是否相等。
- 引用相等一般比较的是他们指向的内存地址是否相等。

```java
// 对象相等与引用相等的示例

String str1 = "hello";
String str2 = new String("hello");
String str3 = "hello";
// 使用 == 比较字符串的引用相等
System.out.println(str1 == str2);
System.out.println(str1 == str3);
// 使用 equals 方法比较字符串的相等
System.out.println(str1.equals(str2));
System.out.println(str1.equals(str3));
```

```
// 输出

false  // str1指向字符串常量池，str2指向堆内存
true   // str1 str2 都指向了字符串常量池
true   // String.equals比较的是内容
true   // String.equals比较的是内容
```



####  如果一个类没有声明构造方法，该程序能正确执行吗?

构造方法是一种特殊的方法，主要作用是完成对象的初始化工作。

如果一个类没有声明构造方法，也可以执行！因为一个类即使没有声明构造方法也会有默认的不带参数的构造方法。如果我们自己添加了类的构造方法（无论是否有参），Java 就不会添加默认的无参数的构造方法了。



#### 构造方法有哪些特点？是否可被 override?

构造方法特点如下：

- 名字与类名相同。
- 没有返回值，但不能用 void 声明构造函数。
- 创建类的对象时自动执行，无需调用。

构造方法不能被 override（重写）,但是可以 overload（重载），所以你可以看到一个类中有多个构造函数的情况。



#### 面向对象三大特征

- 封装、继承、多态

  > 封装：封装是指把一个对象的状态信息，即属性，隐藏在对象内部，不允许外部对象直接访问对象的内部信息。但是可以提供一些可以被外界访问的方法来操作属性。（合理隐藏、合理暴露）

  > 继承：不同类型的对象，相互之间经常有一定数量的共同点。继承是使用已存在的类的定义作为基础建立新类的技术，新类的定义可以增加新的数据或新的功能，也可以用父类的功能，但不能选择性地继承父类。通过使用继承，可以快速地创建新的类，可以提高代码的重用性，程序的可维护性，节省大量创建新类的时间 ，提高开发效率。
  >
  > > 继承的注意点：
  > >
  > > 1. 子类拥有父类对象所有的属性和方法（包括私有属性和私有方法），但是父类中的私有属性和方法子类是无法访问，**只是拥有**。
  > > 2. 子类可以拥有自己属性和方法，即子类可以对父类进行扩展。
  > > 3. 子类可以用自己的方式实现父类的方法。

  > 多态：表示一个对象具有多种的状态，具体表现为父类的引用指向子类的实例。
  >
  > > 多态的特点：
  > >
  > > 1. 对象类型和引用类型之间具有继承（类）/实现（接口）的关系。
  > > 2. 引用类型变量发出的方法调用的到底是哪个类中的方法，必须在程序运行期间才能确定。
  > > 3. 多态不能调用“只在子类存在但在父类不存在”的方法。
  > > 4. 如果子类重写了父类的方法，真正执行的是子类覆盖的方法，如果子类没有覆盖父类的方法，执行的是父类的方法。

  

#### 接口和抽象类有什么共同点和区别？

共同点：

- 都不能被实例化。
- 都可以包含抽象方法（接口的方法都是抽象的、抽象类的方法可以包含抽象也可以包含实例方法）。
- 都可以有默认实现的方法（Java 8 可以用 `default` 关键字在接口中定义默认方法）。

区别：

- 接口主要用于对类的行为进行约束，你实现了某个接口就具有了对应的行为。抽象类主要用于代码复用，强调的是所属关系。
- 一个类只能继承一个类，但是可以实现多个接口。
- 接口中的成员变量只能是 `public static final` 类型的，不能被修改且必须有初始值，而抽象类的成员变量默认 default，可在子类中被重新定义，也可被重新赋值。



#### 深拷贝和浅拷贝区别了解吗？什么是引用拷贝？

- **浅拷贝**：浅拷贝会在堆上创建一个新的对象（区别于引用拷贝的一点），不过，如果原对象内部的属性是引用类型的话，浅拷贝会直接复制内部对象的引用地址，也就是说拷贝对象和原对象共用同一个内部对象。
- **深拷贝**：深拷贝会完全复制整个对象，包括这个对象所包含的内部对象。
- **引用拷贝**：引用拷贝就是两个不同的引用指向同一个对象。

![浅拷贝、深拷贝、引用拷贝示意图](https://raw.githubusercontent.com/ZXJ-OvO/picgo-img/master/202307101047625.png)



### Object

#### Object 类的常见方法有哪些？

Object 类是一个特殊的类，是所有类的父类。它主要提供了以下 11 个方法：

```java
/**
 * native 方法，用于返回当前运行时对象的 Class 对象，使用了 final 关键字修饰，故不允许子类重写。
 */
public final native Class<?> getClass();
/**
 * native 方法，用于返回对象的哈希码，主要使用在哈希表中，比如 JDK 中的HashMap。
 */
public native int hashCode();
/**
 * 用于比较 2 个对象的内存地址是否相等，String 类对该方法进行了重写以用于比较字符串的值是否相等。
 */
public boolean equals(Object obj) { };
/**
 * native 方法，用于创建并返回当前对象的一份拷贝。
 */
protected native Object clone() throws CloneNotSupportedException;
/**
 * 返回类的名字实例的哈希码的 16 进制的字符串。建议 Object 所有的子类都重写这个方法。
 */
public String toString() { }
/**
 * native 方法，并且不能重写。唤醒一个在此对象监视器上等待的线程(监视器相当于就是锁的概念)。如果有多个线程在等待只会任意唤醒一个。
 */
public final native void notify();
/**
 * native 方法，并且不能重写。跟 notify 一样，唯一的区别就是会唤醒在此对象监视器上等待的所有线程，而不是一个线程。
 */
public final native void notifyAll();
/**
 * native方法，并且不能重写。暂停线程的执行。注意：sleep 方法没有释放锁，而 wait 方法释放了锁 ，timeout 是等待时间。
 */
public final native void wait(long timeout) throws InterruptedException;
/**
 * 多了 nanos 参数，这个参数表示额外时间（以毫微秒为单位，范围是 0-999999）。 所以超时的时间还需要加上 nanos 毫秒。。
 */
public final void wait(long timeout, int nanos) throws InterruptedException { }
/**
 * 跟之前的2个wait方法一样，只不过该方法一直等待，没有超时时间这个概念
 */
public final void wait() throws InterruptedException { }
/**
 * 实例被垃圾回收器回收的时候触发的操作
 */
protected void finalize() throws Throwable { }
```

#### == 和 equals() 的区别

**`==`** 对于基本类型和引用类型的作用效果是不同的：

- 对于基本数据类型来说，`==` 比较的是值。

- 对于引用数据类型来说，`==` 比较的是对象的内存地址。

  > 因为 Java 只有值传递，所以，对于 == 来说，不管是比较基本数据类型，还是引用数据类型的变量，其本质比较的都是值，只是引用类型变量存的值是对象的地址。

  

**`equals()`** 不能用于判断基本数据类型的变量，只能用来判断两个对象是否相等。`equals()`方法存在于`Object`类中，而`Object`类是所有类的直接或间接父类，因此所有的类都有`equals()`方法。

`equals()` 方法存在两种使用情况：

**类没有重写 `equals()`方法**：通过`equals()`比较该类的两个对象时，等价于通过“==”比较这两个对象，使用的默认是 `Object`类`equals()`方法。

**类重写了 `equals()`方法**：一般我们都重写 `equals()`方法来比较两个对象中的属性是否相等；若它们的属性相等，则返回 true(即，认为这两个对象相等)。



`String` 中的 `equals` 方法是被重写过的，因为 `Object` 的 `equals` 方法是比较的对象的内存地址，而 `String` 的 `equals` 方法比较的是对象的值。

当创建 `String` 类型的对象时，虚拟机会在常量池中查找有没有已经存在的值和要创建的值相同的对象，如果有就把它赋给当前引用。如果没有就在常量池中重新创建一个 `String` 对象。



#### hashCode() 有什么用？

`hashCode()` 的作用是获取哈希码（`int` 整数），也称散列码。哈希码的作用是确定该对象在哈希表中的索引位置。

`hashCode()` 定义在 JDK 的 `Object` 类中，这就意味着 Java 中的任何类都包含有 `hashCode()` 函数。另外需要注意的是：`Object` 的 `hashCode()` 方法是本地方法（**native**），也就是用 C 语言或 C++ 实现的。

散列表存储的是键值对(key-value)，它的特点是：**能根据“键”快速的检索出对应的“值”。这其中就利用到了散列码！（可以快速找到所需要的对象**



#### 为什么要有 hashCode？

> 以 “`HashSet` 如何检查重复” 为例子来说明为什么要有 `hashCode`？
>
> 
>
> 当你把对象加入 `HashSet` 时，`HashSet` 会先计算对象的 `hashCode` 值来判断对象加入的位置，同时也会与其他已经加入的对象的 `hashCode` 值作比较，如果没有相符的 `hashCode`，`HashSet` 会假设对象没有重复出现。但是如果发现有相同 `hashCode` 值的对象（发生**“哈希碰撞”**），这时会调用 `equals()` 方法来检查 `hashCode` 相等的对象是否真的相同。如果两者相同，`HashSet` 就不会让其加入操作成功。如果不同的话，就会重新散列到其他位置。这样我们就大大减少了 `equals` 的次数，相应就大大提高了执行速度。

其实， `hashCode()` 和 `equals()`都是用于比较两个对象是否相等。

这是因为在一些容器（比如 `HashMap`、`HashSet`）中，有了 `hashCode()` 之后，判断元素是否在对应容器中的效率会更高（参考添加元素进`HashSet`的过程）！

我们在前面也提到了添加元素进`HashSet`的过程，如果 `HashSet` 在对比的时候，同样的 `hashCode` 有多个对象，它会继续使用 `equals()` 来判断是否真的相同。也就是说 `hashCode` 帮助我们大大缩小了查找成本。

**那为什么不只提供 `hashCode()` 方法呢？**

这是因为两个对象的`hashCode` 值相等并不代表两个对象就相等。

**那为什么两个对象有相同的 `hashCode` 值，它们也不一定是相等的？**

因为 `hashCode()` 所使用的哈希算法也许刚好会让多个对象传回相同的哈希值。越糟糕的哈希算法越容易碰撞，但这也与数据值域分布的特性有关（所谓哈希碰撞也就是指的是不同的对象得到相同的 `hashCode` )。

总结下来就是：

- 如果两个对象的`hashCode` 值相等，那这两个对象不一定相等（哈希碰撞）。
- 如果两个对象的`hashCode` 值相等并且`equals()`方法也返回 `true`，我们才认为这两个对象相等。
- 如果两个对象的`hashCode` 值不相等，我们就可以直接认为这两个对象不相等。



#### 为什么重写 equals() 时必须重写 hashCode() 方法？

因为两个相等的对象的 `hashCode` 值必须是相等。也就是说如果 `equals` 方法判断两个对象是相等的，那这两个对象的 `hashCode` 值也要相等。

如果重写 `equals()` 时没有重写 `hashCode()` 方法的话就可能会导致 `equals` 方法判断是相等的两个对象，`hashCode` 值却不相等。

**总结**：

- `equals` 方法判断两个对象是相等的，那这两个对象的 `hashCode` 值也要相等。
- 两个对象有相同的 `hashCode` 值，他们也不一定是相等的（哈希碰撞）。



### String

#### String、StringBuffer、StringBuilder 的区别？

|            |                           String                            |                        StringBuilder                         |                         StringBuffer                         |
| ---------- | :---------------------------------------------------------: | :----------------------------------------------------------: | :----------------------------------------------------------: |
| 可变性     |                           不可变                            | `StringBuilder` 与 `StringBuffer` 都继承自 `AbstractStringBuilder` ，在 `AbstractStringBuilder` 中也是使用字符数组保存字符串，不过没有使用 `final` 和 `private` 关键字修饰。`AbstractStringBuilder` 类还提供了很多修改字符串的方法比如 `append` 方法。 |                              /                               |
| 线程安全性 | `String` 中的对象是不可变的，也就可以理解为常量，线程安全。 | `StringBuilder` 并没有对方法进行加同步锁，所以是非线程安全的。 | `StringBuffer` 对方法加了同步锁或者对调用的方法加了同步锁，所以是线程安全的。 |
| 性能       |                             差                              |               比StringBuffer略高（甚至可忽略）               |                             优秀                             |

**对于三者使用的总结：**

1. 操作少量的数据: 适用 `String`
2. 单线程操作字符串缓冲区下操作大量数据: 适用 `StringBuilder`
3. 多线程操作字符串缓冲区下操作大量数据: 适用 `StringBuffer`



#### String 为什么是不可变的?

`String` 类中使用 `final` 关键字修饰字符数组来保存字符串。

我们知道被 `final` 关键字修饰的类不能被继承、修饰的方法不能被重写、修饰的变量是基本数据类型则值不能改变、修饰的变量是引用类型则不能再指向其他对象。

因此，`final` 关键字修饰的数组保存字符串并不是 `String` 不可变的根本原因，因为这个数组保存的字符串是可变的（`final` 修饰引用类型变量的情况）。

`String` 真正不可变有下面几点原因：

1. 保存字符串的数组被 `final` 修饰且为私有的，并且`String` 类没有提供/暴露修改这个字符串的方法。
2. `String` 类被 `final` 修饰导致其不能被继承，进而避免了子类破坏 `String` 不可变。

> 在 Java 9 之后，`String`、`StringBuilder` 与 `StringBuffer` 的实现改用 `byte` 数组存储字符串。
>
> > **Java 9 为何要将 `String` 的底层实现由 `char[]` 改成了 `byte[]` ?**
> >
> > 新版的 String 其实支持两个编码方案：Latin-1 和 UTF-16。如果字符串中包含的汉字没有超过 Latin-1 可表示范围内的字符，那就会使用 Latin-1 作为编码方案。Latin-1 编码方案下，`byte` 占一个字节(8 位)，`char` 占用 2 个字节（16），`byte` 相较 `char` 节省一半的内存空间。
> >
> > JDK 官方就说了绝大部分字符串对象只包含 Latin-1 可表示的字符。
> >
> > 如果字符串中包含的汉字超过 Latin-1 可表示范围内的字符，`byte` 和 `char` 所占用的空间是一样的。



#### 字符串拼接用“+” 还是 StringBuilder?

- Java 语言本身并不支持运算符重载，“+”和“+=”是专门为 String 类重载过的运算符，也是 Java 中仅有的两个重载过的运算符。

- 字符串对象通过“+”的字符串拼接方式，实际上是通过 `StringBuilder` 调用 `append()` 方法实现的，拼接完成之后调用 `toString()` 得到一个 `String` 对象 。

- 不过，在循环内使用“+”进行字符串的拼接的话，存在比较明显的缺陷：**编译器不会创建单个 `StringBuilder` 以复用，会导致创建过多的 `StringBuilder` 对象**。

- `StringBuilder` 对象是在循环内部被创建的，这意味着每循环一次就会创建一个 `StringBuilder` 对象。

- 如果直接使用 `StringBuilder` 对象进行字符串拼接的话，就不会存在这个问题了。

  > 不过，使用 “+” 进行字符串拼接会产生大量的临时对象的问题在 JDK9 中得到了解决。在 JDK9 当中，字符串相加 “+” 改为了用动态方法 `makeConcatWithConstants()` 来实现，而不是大量的 `StringBuilder` 了。



#### String#equals() 和 Object#equals() 有何区别？

- `String` 中的 `equals` 方法是被重写过的，比较的是 String 字符串的值是否相等。 

- `Object` 的 `equals` 方法是比较的对象的内存地址。



#### 字符串常量池的作用了解吗？

**字符串常量池** 是 JVM 为了提升性能和减少内存消耗针对字符串（String 类）专门开辟的一块区域，主要目的是为了避免字符串的重复创建。



#### String s1 = new String("abc");这句话创建了几个字符串对象？

会创建 1 或 2 个字符串对象。

1. 如果字符串常量池中不存在字符串对象“abc”的引用，那么它将首先在字符串常量池中创建，然后在堆空间中创建，因此将创建总共 2 个字符串对象。
2. 如果字符串常量池中已存在字符串对象“abc”的引用，则只会在堆中创建 1 个字符串对象“abc”。



#### String#intern 方法有什么作用?

`String.intern()` 是一个 native（本地）方法，其作用是将指定的字符串对象的引用保存在字符串常量池中，可以简单分为两种情况：

- 如果字符串常量池中保存了对应的字符串对象的引用，就直接返回该引用。
- 如果字符串常量池中没有保存了对应的字符串对象的引用，那就在常量池中创建一个指向该字符串对象的引用并返回

```java
// 在堆中创建字符串对象”Java“
// 将字符串对象”Java“的引用保存在字符串常量池中
String s1 = "Java";
// 直接返回字符串常量池中字符串对象”Java“对应的引用
String s2 = s1.intern();
// 会在堆中在单独创建一个字符串对象
String s3 = new String("Java");
// 直接返回字符串常量池中字符串对象”Java“对应的引用
String s4 = s3.intern();
// s1 和 s2 指向的是堆中的同一个对象
System.out.println(s1 == s2); // true
// s3 和 s4 指向的是堆中不同的对象
System.out.println(s3 == s4); // false
// s1 和 s4 指向的是堆中的同一个对象
System.out.println(s1 == s4); //true
```



#### String 类型的变量和常量做“+”运算时发生了什么？

**对于编译期可以确定值的字符串，也就是常量字符串 ，jvm 会将其存入字符串常量池。并且，字符串常量拼接得到的字符串常量在编译阶段就已经被存放字符串常量池，这个得益于编译器的优化。**

在编译过程中，Javac 编译器（下文中统称为编译器）会进行一个叫做 **常量折叠(Constant Folding)** 的代码优化。

> 常量折叠会把常量表达式的值求出来作为常量嵌在最终生成的代码中，这是 Javac 编译器会对源代码做的极少量优化措施之一(代码优化几乎都在即时编译器中进行)。

并不是所有的常量都会进行折叠，只有编译器在程序编译期就可以确定值的常量才可以：

- 基本数据类型( `byte`、`boolean`、`short`、`char`、`int`、`float`、`long`、`double`)以及字符串常量。
- `final` 修饰的基本数据类型和字符串变量。
- 字符串通过 “+”拼接得到的字符串、基本数据类型之间算数运算（加减乘除）、基本数据类型的位运算（<<、>>、>>> ）。

**引用的值在程序编译期是无法确定的，编译器无法对其进行优化。**

> 对象引用和“+”的字符串拼接方式，实际上是通过 `StringBuilder` 调用 `append()` 方法实现的，拼接完成之后调用 `toString()` 得到一个 `String` 对象 。

> 我们在平时写代码的时候，尽量避免多个字符串对象拼接，因为这样会重新创建对象。如果需要改变字符串的话，可以使用 `StringBuilder` 或者 `StringBuffer`。
>
> 不过，字符串使用 `final` 关键字声明之后，可以让编译器当做常量来处理。
>
> 被 `final` 关键字修改之后的 `String` 会被编译器当做常量来处理，编译器在程序编译期就可以确定它的值，其效果就相当于访问常量。
>
> 如果 ，编译器在运行时才能知道其确切值的话，就无法对其优化。





## 并发编程

## IO/NIO

## JVM

## JDK新特性

# 计算机基础

## 计算机网络

## 操作系统

## 数据结构

## 算法

# 数据库

## 数据库基础

## MySQL

## Redis

## Elasticsearch

## MongoDB

# 开发工具

## Maven

## Gradle

## Git

## Docker

## IDEA

# 框架

## Spring

## SpringBoot

## 常用注解

## MyBatis

## Netty

# 系统设计

## 基础设计

## 安全设计

## 设计模式

## Java定时任务

## Web实时消息推送

# 分布式

## 理论&算法&协议

## API网关

## 分布式ID

## 分布式锁

## RPC

## Zookeeper

## 分布式事务

## 分布式事务配置中心

# 高性能

## CDN

## 负载均衡

## 数据库优化

## 消息队列

# 高可用

## 系统设计

## 冗余设计

## 服务限流

## 熔断降级

## 超时重试

## 性能测试