# Java

## SE基础

### 基础概念

#### Java 语言有哪些特点?

1. 简单易学；
2. 面向对象；
3. 可移植性；
4. 支持多线程；
5. 可靠性（具备异常处理和自动内存管理机制）；
6. 安全性（Java 语言本身的设计就提供了多重安全防护机制如访问权限修饰符、限制程序直接访问操作系统资源）；
7. 高效性（Just In Time 编译器等技术的优化）；
8. 支持网络编程；
9. 编译与解释并存；
10. 强大的生态



#### JVM vs JDK vs JRE

![jdk-include-jre](https://raw.githubusercontent.com/ZXJ-OvO/picgo-img/master/202307081015692.png)



####  什么是字节码?采用字节码的好处是什么?

1. 在 Java 中，JVM 可以理解的代码就叫做字节码，即扩展名为 `.class` 的文件，它不面向任何特定的处理器，只面向虚拟机。
2. Java 语言通过字节码的方式，在一定程度上解决了传统解释型语言执行效率低的问题，同时又保留了解释型语言可移植的特点。因此，Java 程序运行时相对来说还是高效的，而且，由于字节码并不针对一种特定的机器，因此实现了一次编译随处运行。



#### 为什么说Java 是编译与解释共存的语言

`.class->机器码` 这一步 **JVM 类加载器**首先加载字节码文件，然后通过**解释器**逐行解释执行，这种方式的执行速度会相对比较慢。而且，有些方法和代码块是经常需要被调用的（即热点代码），所以后面引进了 JIT（just-in-time compilation） 编译器，而 JIT 属于运行时编译。当 JIT 编译器完成第一次编译后，其会将字节码对应的机器码保存下来，下次可以直接使用。而我们知道，机器码的运行效率肯定是高于 Java 解释器的。这也解释了我们为什么经常会说 **Java 是编译与解释共存的语言** 。

HotSpot 采用了惰性评估(Lazy Evaluation)的做法，根据二八定律，消耗大部分系统资源的只有那一小部分的代码（热点代码），而这也就是 JIT 所需要编译的部分。JVM 会根据代码每次被执行的情况收集信息并相应地做出一些优化，因此执行的次数越多，它的速度就越快。

JDK 9 引入了一种新的编译模式 AOT(Ahead of Time Compilation)，它是直接将字节码编译成机器码，这样就避免了 JIT 预热等各方面的开销。JDK 支持分层编译和 AOT 协作使用。

![image-20230708103222895](https://raw.githubusercontent.com/ZXJ-OvO/picgo-img/master/202307081032928.png)



#### AOT 可以提前编译节省启动时间为什么不全部使用 AOT 

这和 Java 语言的动态特性有联关系。例如，CGLIB 动态代理使用的是 ASM 技术，而这种技术大致原理是运行时直接在内存中生成并加载修改后的字节码文件也就是 `.class` 文件，如果全部使用 AOT 提前编译，也就不能使用 ASM 技术了。为了支持类似的动态特性，所以选择使用 JIT 即时编译器。



#### Oracle JDK vs OpenJDK

| Oracle JDK           | Open JDK      |
| -------------------- | ------------- |
| 部分内容闭源         | 完全开源      |
| 有限的免费版本       | 完全免费      |
| 功能更强             | 基础功能      |
| 约3年发布一个LTS版本 | 不提供LTS版本 |



### 基本语法

#### 注释有哪几种形式？

1. **单行注释**：通常用于解释方法内某单行代码的作用。
2. **多行注释**：通常用于解释一段代码的作用。
3. **文档注释**：通常用于生成 Java 开发文档。



####  标识符和关键字的区别是什么？

标识符就是一个名字，关键字是被赋予特殊含义的标识符。

|                      |          |            | 关键字   |              |            |           |        |
| :------------------- | -------- | ---------- | -------- | ------------ | ---------- | --------- | ------ |
| 分类                 | 关键字   |            |          |              |            |           |        |
| 访问控制             | private  | protected  | public   |              |            |           |        |
| 类，方法和变量修饰符 | abstract | class      | extends  | final        | implements | interface | native |
|                      | new      | static     | strictfp | synchronized | transient  | volatile  | enum   |
| 程序控制             | break    | continue   | return   | do           | while      | if        | else   |
|                      | for      | instanceof | switch   | case         | default    | assert    |        |
| 错误处理             | try      | catch      | throw    | throws       | finally    |           |        |
| 包相关               | import   | package    |          |              |            |           |        |
| 基本类型             | boolean  | byte       | char     | double       | float      | int       | long   |
|                      | short    |            |          |              |            |           |        |
| 变量引用             | super    | this       | void     |              |            |           |        |
| 保留字               | goto     | const      |          |              |            |           |        |

> ⚠️ 注意：虽然 `true`, `false`, 和 `null` 看起来像关键字但实际上他们是字面值，同时也不可以作为标识符来使用。



####  自增自减运算符

“符号在前就先加/减，符号在后就后加/减”。



#### 移位运算符

- `<<` :左移运算符，向左移若干位，高位丢弃，低位补零。`x << 1`,相当于 x 乘以 2(不溢出的情况下)。
- `>>` :带符号右移，向右移若干位，高位补符号位，低位丢弃。正数高位补 0,负数高位补 1。`x >> 1`,相当于 x 除以 2。
- `>>>` :无符号右移，忽略符号位，空位都以 0 补齐。

>由于 `double`，`float` 在二进制中的表现比较特殊，因此不能来进行移位操作。
>
>移位操作符实际上支持的类型只有`int`和`long`，编译器在对`short`、`byte`、`char`类型进行移位前，都会将其转换为`int`类型再操作。
>
><hr/>
>
>当 int 类型左移/右移位数大于等于 32 位操作时，会先求余（%）后再进行左移/右移操作。也就是说左移/右移 32 位相当于不进行移位操作（32%32=0），左移/右移 42 位相当于左移/右移 10 位（42%32=10）。当 long 类型进行左移/右移操作时，由于 long 对应的二进制是 64 位，因此求余操作的基数也变成了 64。
>
>也就是说：`x<<42`等同于`x<<10`，`x>>42`等同于`x>>10`，`x >>>42`等同于`x >>> 10`。

```java
// 右移运算符代码示例：

int i = -1;
System.out.println("初始数据：" + i);
System.out.println("初始数据对应的二进制字符串：" + Integer.toBinaryString(i));
i <<= 10;
System.out.println("左移 10 位后的数据 " + i);
System.out.println("左移 10 位后的数据对应的二进制字符 " + Integer.toBinaryString(i));
i <<= 42;
System.out.println("左移 10 位后的数据 " + i);
System.out.println("左移 10 位后的数据对应的二进制字符 " + Integer.toBinaryString(i));
```

```
// 输出

初始数据：-1
初始数据对应的二进制字符串：11111111111111111111111111111111
左移 10 位后的数据 -1024
左移 10 位后的数据对应的二进制字符 11111111111111111111110000000000
左移 10 位后的数据 -1024
左移 10 位后的数据对应的二进制字符 11111111111111111111110000000000
```

####  continue、break 和 return 的区别是什么？

1. `continue`：指跳出当前的这一次循环，继续下一次循环。
2. `break`：指跳出整个循环体，继续执行循环下面的语句。
3. `return` 用于跳出所在方法，结束该方法的运行。return 一般有两种用法：
   - `return;`：直接使用 return 结束方法执行，用于没有返回值函数的方法。
   - `return value;`：return 一个特定值，用于有返回值函数的方法。



#### 基本数据类型

| 基本类型  | 位数 | 字节 | 默认值  | 取值范围                                   | 包装类    |
| :-------- | :--- | :--- | :------ | ------------------------------------------ | --------- |
| `byte`    | 8    | 1    | 0       | -128 ~ 127                                 | Byte      |
| `short`   | 16   | 2    | 0       | -32768 ~ 32767                             | Short     |
| `int`     | 32   | 4    | 0       | -2147483648 ~ 2147483647                   | Integer   |
| `long`    | 64   | 8    | 0L      | -9223372036854775808 ~ 9223372036854775807 | Long      |
| `char`    | 16   | 2    | 'u0000' | 0 ~ 65535                                  | Character |
| `float`   | 32   | 4    | 0f      | 1.4E-45 ~ 3.4028235E38                     | Float     |
| `double`  | 64   | 8    | 0d      | 4.9E-324 ~ 1.7976931348623157E308          | Double    |
| `boolean` | 1    |      | false   | true、false                                | Boolean   |

> - 在Java中，局部变量（如在方法内部定义的变量）没有默认值，必须显式地初始化才能使用。这是因为局部变量的值是不确定的，直到你为其赋予一个具体的值。
> - 但是类的成员变量（即类的字段）会根据其类型有默认值。
> - 所有引用类型的默认值都是null（包装类属于引用类型）。



#### 基本数据类型和包装类型的区别？

1. **用途**：除了定义一些常量和局部变量之外，在其他地方很少使用基本类型。并且包装类型可用于泛型，基本类型不可以。
2. **存储方式**：基本数据类型的局部变量存放在 Java 虚拟机栈中的局部变量表中，基本数据类型的成员变量（未被 `static` 修饰 【static修饰】的静态变量位于方法区中）存放在 Java 虚拟机的堆中。包装类型属于对象类型，我们知道几乎所有对象实例都存在于堆中。
3. **占用空间**：相比于包装类型（对象类型）， 基本数据类型占用的空间往往非常小。
4. **默认值**：成员变量包装类型不赋值就是 `null` ，而基本类型有默认值且不是 `null`。
5. **比较方式**：对于基本数据类型来说，`==` 比较的是值。对于包装数据类型来说，`==` 比较的是对象的内存地址。所有整型包装类对象之间值的比较，全部使用 `equals()` 方法。

**为什么说是几乎所有对象实例都存在于堆中呢？** 这是因为 HotSpot 虚拟机引入了 JIT 优化之后，会对对象进行逃逸分析，如果发现某一个对象并没有逃逸到方法外部，那么就可能通过标量替换来实现栈上分配，而避免堆上分配内存。

> ⚠️ 注意：**基本数据类型存放在栈中是一个常见的误区！** 基本数据类型的成员变量如果没有被 `static` 修饰的话（不建议这么使用，应该要使用基本数据类型对应的包装类型），就存放在堆中。



#### 包装类型的缓存机制了解么？

Java 基本数据类型的包装类型的大部分都用到了缓存机制来提升性能。

- `Byte`,`Short`,`Integer`,`Long` 这 4 种包装类默认创建了数值 **[-128，127]** 的相应类型的缓存数据。
- `Character` 创建了数值在 **[0,127]** 范围的缓存数据。
- `Boolean` 直接返回 `True` or `False`。
- 如果超出对应范围仍然会去创建新的对象，缓存的范围区间的大小只是在性能和资源之间的权衡。
- 两种浮点数类型的包装类 `Float`,`Double` 并没有实现缓存机制。

```java
int a = 100;
int b = 200;

Integer c = a; // 100
Integer d = a; // 100
Integer e = b; // 200
Integer f = b; // 200

long l = 100l;
Long ll = l; // 100

System.out.println(c == d);       //true  Integer值100在Integer的缓存范围中，所以指向同一个对象，即地址相同
System.out.println(e == f);       //false Integer的缓存范围是-128~127，200超出了缓存范围中，所以指向不同的对象，即地址不同
System.out.println(a == l);       //true  字符串常量池中byte short int long类型的范围是-128~127，所以指向同一个对象，即地址相同
System.out.println(c == l);       //true  包装类在与基本数据类型做==比较时，包装类型会自动拆箱为基本数据类型，所以比较的是基本数据类型，即地址相同
System.out.println(e.equals(f));  //true  包装类的equals方法重写过，当比较双方的类型不同时，返回false；当比较双方的类型相同时，比较的是实际数据值
System.out.println(c.equals(l));  //false 类型不同，返回false
System.out.println(c.equals(ll)); //false 类型不同，返回false

Float i11 = 333f;
Float i22 = 333f;
System.out.println(i11 == i22);// 输出 false

Double i3 = 1.2;
Double i4 = 1.2;
System.out.println(i3 == i4);// 输出 false

Integer i1 = 40;
Integer i2 = new Integer(40);
System.out.println(i1 == i2);        // false
// Integer i1=40 会发生装箱，等价于Integer i1=Integer.valueOf(40) 因此，i1 直接使用的是缓存中的对象。而Integer i2 = new Integer(40) 会直接创建新的对象。
```

> 《阿里巴巴Java开发规约》【强制】**所有整型包装类对象之间值的比较，全部使用 equals 方法比较**



#### 自动装箱与拆箱了解吗？原理是什么？

- **装箱**：将基本类型用它们对应的引用类型包装起来；
- **拆箱**：将包装类型转换为基本数据类型；

装箱其实就是调用了 包装类的`valueOf()`方法，拆箱其实就是调用了 `xxxValue()`方法。

因此，

- `Integer i = 10` 等价于 `Integer i = Integer.valueOf(10)`

- `int n = i` 等价于 `int n = i.intValue()`;

> ⚠️**如果频繁拆装箱的话，也会严重影响系统的性能。我们应该尽量避免不必要的拆装箱操作。**



#### 为什么浮点数运算的时候会有精度丢失的风险？

计算机底层是二进制的，而且计算机在表示一个数字时，宽度是有限的，无限循环的小数存储在计算机时，只能被截断，所以就会导致小数精度发生损失的情况。



#### 如何解决浮点数运算的精度丢失问题？

`BigDecimal` 可以实现对浮点数的运算，不会造成精度丢失。通常情况下，大部分需要浮点数精确运算结果的业务场景（比如涉及到钱的场景）都是通过 `BigDecimal` 来做的。



#### 超过 long 整型的数据应该如何表示？

`BigInteger` 内部使用 `int[]` 数组来存储任意大小的整形数据。

相对于常规整数类型的运算来说，`BigInteger` 运算的效率会相对较低。



#### 成员变量与局部变量的区别？

|          | 成员变量                                                     | 局部变量                                                     |
| -------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 定义位置 | 属于类（类中方法外）                                         | 代码块、方法内的变量、方法的参数                             |
| 修饰符   | public、private、static、final                               | final                                                        |
| 存储方式 | 静态成员变量（类变量）：方法区<br />非静态成员变量（实例变量）：堆内存 | 栈内存                                                       |
| 生存时间 | 实例变量随着对象的创建而诞生，随着对象的消亡而消亡<br />类变量在程序执行期间一直存在，被所有对象实例共享 | 局部变量的生存时间仅限于它们所在的作用域，当作用域结束时销毁 |
| 默认值   | 从变量是否有默认值来看，成员变量如果没有被赋初始值，则会自动以类型的默认值而赋值（一种情况例外:被 `final` 修饰的成员变量也必须显式地赋值） | 而局部变量则不会自动赋值                                     |



####  静态变量有什么作用？

- 静态变量也就是被 `static` 关键字修饰的变量。它可以被类的所有实例共享，无论一个类创建了多少个对象，它们都共享同一份静态变量。也就是说，静态变量只会被分配一次内存，即使创建多个对象，这样可以节省内存。
- 静态变量是通过类名来访问的（如果被 `private`关键字修饰就无法这样访问了，可以提供暴露的方法进行访问）。
- 通常情况下，静态变量会被 `final` 关键字修饰成为常量。



####  字符型常量和字符串常量的区别?

- **形式** : 字符常量是单引号引起的一个字符，字符串常量是双引号引起的 0 个或若干个字符。
- **含义** : 字符常量相当于一个整型值( ASCII 值),可以参加表达式运算; 字符串常量代表一个地址值(该字符串在内存中存放位置)。
- **占内存大小**：字符常量只占 2 个字节; 字符串常量占若干个字节。



#### 什么是方法的返回值?方法有哪几种类型？

**方法的返回值** 是指我们获取到的某个方法体中的代码执行后产生的结果！（前提是方法返回某个值）

按照方法的返回值和参数类型将方法分为下面这几种：

1. 无参数无返回值的方法
2. 有参数无返回值的方法
3. 无参数有返回值的方法
4. 有参数有返回值的方法



#### 静态方法为什么不能调用非静态成员?

1. 静态方法是属于类的，在类加载的时候就会分配内存，可以通过类名直接访问。而非静态成员属于实例对象，只有在对象实例化之后才存在，需要通过类的实例对象去访问。
2. 在类的非静态成员不存在的时候静态方法就已经存在了，此时调用在内存中还不存在的非静态成员，属于非法操作。



#### 静态方法和实例方法有何不同？

1. 调用方式
   - 在外部调用静态方法时，可以使用 `类名.方法名` 的方式，也可以使用 `对象.方法名` 的方式，而实例方法只有后面这种方式。也就是说，**调用静态方法可以无需创建对象** 。
   - 不过，需要注意的是一般不建议使用 `对象.方法名` 的方式来调用静态方法。这种方式非常容易造成混淆，静态方法不属于类的某个对象而是属于这个类。
   - 因此，一般建议使用 `类名.方法名` 的方式来调用静态方法。

2. 访问类成员是否存在限制
   - 静态方法在访问本类的成员时，只允许访问静态成员（即静态成员变量和静态方法）。
   - 不允许访问实例成员（即实例成员变量和实例方法），而实例方法不存在这个限制。



####  重载和重写有什么区别？

| 区别点     | 重载方法 | 重写方法                                                     |
| :--------- | :------- | :----------------------------------------------------------- |
| 发生范围   | 同一个类 | 子类                                                         |
| 参数列表   | 必须修改 | 一定不能修改                                                 |
| 返回类型   | 可修改   | 子类方法返回值类型应比父类方法返回值类型更小或相等           |
| 异常       | 可修改   | 子类方法声明抛出的异常类应比父类方法声明抛出的异常类更小或相等 |
| 访问修饰符 | 可修改   | 子类的访问修饰符范围大于等于父类                             |
| 发生阶段   | 编译期   | 运行期                                                       |

> 关于 **重写的返回值类型** 这里需要额外多说明一下，上面的表述不太清晰准确：如果方法的返回类型是 void 和基本数据类型，则返回值重写时不可修改。但是如果方法的返回值是引用类型，重写时是可以返回该引用类型的子类的。



#### 什么是可变长参数？

- 从 Java5 开始，Java 支持定义可变长参数，所谓可变长参数就是允许在调用方法时传入不定长度（0个或者多个）的参数。
- 可变参数只能作为函数的最后一个参数，但其前面可以有也可以没有任何其他参数。
- Java 的可变参数编译后实际会被转换成一个数组。

> 遇到方法重载的情况，优先匹配固定参数的方法，因为固定参数的方法匹配度更高。

































































### 数据类型

### 变量

### 方法

## 集合

## 并发编程

## IO

## JVM

## JDK新特性

# 计算机基础

## 计算机网络

## 操作系统

## 数据结构

## 算法

# 数据库

## 数据库基础

## MySQL

## Redis

## Elasticsearch

## MongoDB

# 开发工具

## Maven

## Gradle

## Git

## Docker

## IDEA

# 框架

## Spring

## SpringBoot

## 常用注解

## MyBatis

## Netty

# 系统设计

## 基础设计

## 安全设计

## 设计模式

## Java定时任务

## Web实时消息推送

# 分布式

## 理论&算法&协议

## API网关

## 分布式ID

## 分布式锁

## RPC

## Zookeeper

## 分布式事务

## 分布式事务配置中心

# 高性能

## CDN

## 负载均衡

## 数据库优化

## 消息队列

# 高可用

## 系统设计

## 冗余设计

## 服务限流

## 熔断降级

## 超时重试

## 性能测试